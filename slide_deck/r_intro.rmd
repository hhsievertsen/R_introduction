---
author: Hans Henrik Sievertsen (h.h.sievertsen@bristol.ac.uk)
title: "Introduction to R"
subtitle: "University of Bristol"
date: "Version: January 28 - 2020"
output:
  beamer_presentation:
  keep_tex: no
theme: metropolis
latex_engine: xelatex
slide_level: 2
incremental: no
fontsize: 8pt
classoption: compress
header-includes:
  \setbeamercolor{frametitle}{bg=gray}
  \hypersetup{colorlinks,citecolor=orange,filecolor=red,linkcolor=brown,urlcolor=blue}
  \colorlet{shadecolor}{gray!50}
---

```{r,setup, include=FALSE}
knitr::opts_chunk$set(cache=TRUE)
library(tidyverse)
```
```{r set-options, echo=FALSE, cache=FALSE}
options(width = 600)
```




## Plan

1. Getting started & R basics
    - Downloading and installing R
    - Organization of RStudio
    - Object types, comments, etc
2. Tidyverse
    - Installing and loading packages
    - Importing, tidying, processing & visualizing data.
3. Working with matrices in R
    - Creating vectors & matrices.
    - Matrix multiplication, inverse, determinant etc.
    - Application: OLS estimator
4. Functions, control structures & loops in R
    - User written functions, if-else structures, for & while loops.
    - Application: maximum likelihood estimation 
  

# 1. Getting started & R basics

## Getting started  

1. Download this **slide deck** ,  **example datasets** and **exercises** from [https://github.com/hhsievertsen/R_introduction](https://github.com/hhsievertsen/R_introduction)

2. Download  **R** from [stats.bris.ac.uk/R/](https://www.stats.bris.ac.uk/R/) and install it.

3. Download **RStudio** [https://rstudio.com/](https://rstudio.com/products/rstudio/download/#download) and install it.
                                                 
4. Open R Studio

For more on how to install R and RStudio see chapter 3 in ["R Programming for Data Science" (Peng, 2019)](https://bookdown.org/rdpeng/rprogdatascience/getting-started-with-r.html#installation)

## Organisation of RStudio

\begin{itemize}
\item [A.] Console 
\item [B.] Script editor
\item [C.] Overview of objects
\item [D.] Documentation/plots/file browser/packages
\end{itemize}

```{r rguide2, echo=FALSE, out.width ='50%',fig.show='hold',fig.align='center'}
knitr::include_graphics(c("graphics/rstudio.png"))
```

## R basics: R as a calculator

**R as a calculator** 

- We can use R as a calculator. Try typing the following in console and press enter:

```{r }
5+3
```

- You can also type 5+3 in the script editor, highlight what you just wrote and click `Ctrl`+`Enter`.
- Using the script editor, the keyboard combination `Ctrl`+`Enter` executes the current line or the selected area.

## R basics: the assignment operator

**The assignment operator:** `<-`

```{r }
value1<-5
```
- The number five is assigned to an object named "value1".
- We can also achieve this using `=` instead of `<-` , but I recommend getting used to using `<-` as it will become of advantage later on.

- We can also use named objects in the calculator approach:

```{r }
value1<-5
value1+3
```
## R basics: print()

**Printing**

- We can ask to display the content of an object using `print()`

```{r }
value1<-5
value2<-3
value3<-value1+value2
print(value3)
```
- `R` returns the value of an expression automatically, this is called automatic printing.
```{r }
value1<-5
value2<-3
value3<-value1+value2
value3 
```
- Automatic printing is disabled in loops, functions etc (more on that later).


## R basics: functions

**R functions**

- `print()` is an example of a R function.
- The name of this function is `print`
- The function options (called arguments) go inside the `()`. 
- This is general R syntax: 
- If you include `()` after a name, R knows it is a function. If you don't include `()` R knows it is not a function.

- Functions can accept many arguments inside the `()`.

- **Ordered**  arguments
```{r eval=FALSE}
print(value3,TRUE)
```
  
- **Named**  arguments
```{r eval=FALSE}
print(x=value3,quote=TRUE)
```

## R basics: object type

**Object types**


```{r }
var<-TRUE
typeof(var)
```

```{r }
var<-4L
typeof(var)
```


```{r }
var<-4141.2
typeof(var)
```


```{r }
var<-"Hello1"
typeof(var)
```

- Additional types: NULL,raw, complex, list, expression

## R basics: vectors

**Vectors**

- We **combine** several objects in a vector using the `c()` function.

```{r }
value1<-5
value2<-3
value3<-value1+value2
vector1<-c(value1,value2,value3)
print(vector1)
```

- a list is **homogeneous**: all objects are **coerced** to be of the same type.
```{r }
object1<-414.041
object2<-"hello!"
vector2<-c(object1,object2)
print(vector2)
```
(all objects are strings)

## R basics: entering values


- A range from 1 to 17:

```{r }
vector<-1:17
print(vector)
```

- A range from 1 to 17 in steps of 0.5 using `seq()`:
```{r }
vector<-seq(1,17,by=0.5)
print(vector)
```

- A vector of length 12 with missing values (`NA`) using  `rep()`:
```{r }
vector<-rep(NA,12)
print(vector)
```
 
- A vector of length 12 with draws from a normal distribution:
```{r }
vector<-rnorm(mean=0,sd=1,n=12)
print(vector)
```
## R basics: comments

**Comments**

\begin{itemize}
\item We should annotate our R script with comments about what we are doing.
\item \emph{Problem:} R will try to execute or comments as R code. 
\item \emph{Solution:} Content after the \# symbol is ignored by R.
\item []
\end{itemize}

```{r eval=FALSE}
# This is line is ignored by R
this is not ignored by R # but this is
```

## R basics: useful functions

- Create a list (can be heterogenous) using `list()`
```{r }
a<-"Hello"
b<-1:7
c<-list(a,b)
c
```

- Get the length of an object using `length()`:

```{r }
vector<-seq(0,3,by=0.02)
obj<-length(vector)
```
- Concatenate strings with `paste()`:
```{r }
obj1<-"Hello"
obj2<-"Bristol"
obj3<-paste(obj1,obj2,"!",sep=" ")
print(obj3)
```


## R basics: working directory and documentation

**Working directory**
\begin{itemize}
\item We specify the working directory with `setwd()`.
\item [] (the default location for saving and loading files.)
\end{itemize}
```{r, eval=FALSE }
setwd("C:\\Users\\hs17922\\Documents")
```
- Note: use `\\` instead of `\`.

**R documention**

- Most functions in R are well documented. 
- We can access the documentation by typing `?nameoffunction`. For example:
```{r,eval=FALSE }
?setwd
```

## Getting started and R basics - summary

- We assign objects using the the assignment operator `<-`.
- We specify working directory with `setwd()`.
- We access R documentation for the function called `functionname` with `?functionname`.
- We use the `#` to add comments to our script.
- R has five atomic classes of objects: character, numeric, integer, integer, complex (not covered) and logical.
- We create vectors with `c()` and lists with `list()`.
- Entering values using `rep()` and `seq()`.
- Lists are homogeneous and only contain one object class. 


For more details see chapter 4 in ["R Programming for Data Science" (Peng, 2019)](https://bookdown.org/rdpeng/rprogdatascience/r-nuts-and-bolts.html)



\normalsize
# 2. Tidyverse

## Installing and loading packages

\begin{itemize}
\item R is powerful.
\item R with extra packages is very powerful.
\item \textbf{tidyverse} is a collection of packages (ggplot2, tidyr,readr, dplyr and more) that are useful for working with data.
\item to \textbf{install a package} (examplified by "tidyverse").
\item [] (We need to do this only once on every system.)
\end{itemize}
```{r ,eval=FALSE}
install.packages("tidyverse")
```
\begin{itemize}
\item to \textbf{load a packages} (examplified with "tidyverse").
\item [] (We have to do that once for every R session.)
\end{itemize}
```{r ,message=FALSE}
library("tidyverse")
```
## Loading data into R

**Data formats**

- Datasets come in many formats depending on how they were created and saved (Excel, Stata, etc).
- R can load many types of datasets (but sometimes we have to load a special package to load a specific format).
-  `read_csv()` from the `readr` package (included in tidyverse) is convenient for loading datasets ending on ".csv". 
- Note that  `read.csv()` is a slightly different function. 

## Loading data into R

**Loading data with read_csv()**
```{r,eval=FALSE}
mydataset<-read_csv("example_data1.csv")
```
\tiny
```{r,echo=FALSE}
mydataset<-read_csv("example_data1.csv")
```
\normalsize

- The dataset named "example_data1.csv" in the current working directory is now loaded in R under the name `mydataset`.
- The dataset is loaded with 15 columns.
- The first variable is a character (i.e. text) type variable and all outhers are double precision floating point numbers. 

For more details on importing data see chapter 11 in ["R for data science: import, tidy, transform, visualize, and model data." (Wickham & Grolemund, 2016)](https://r4ds.had.co.nz/data-import.html)




## Viewing data

What is in `mydataset`?

- `print()` will (attempt to) display the full dataset in the console. Not feasible for large datasets.
- `head()` displays the first six observations in the dataset.
``` {r ,eval=FALSE}
head(mydataset)
```
\tiny
```{r,echo=FALSE,width=999}
head(mydataset)
```
\normalsize
- `tail()` displays the last six observations in the dataset.
- We can specify the number of rows to show with `n=6`: `head(mydataset,n=6)` or `tail(mydataset,n=6)` (to show 6 rows, the default).
- `View()` opens the dataset in a viewer. 

## Tidying data I

**Tidy data**

- The **tidy data principles**  state that each *variable* must have its own *column* and each *observation* must have its own row. 
- The example dataset is not tidy. 



  - The variables `test_year_1` to `test_year_9` violate the tidy data principles.
  - The variables contain information about test scores. 
  - The values 1,2,...., 9, and 9 are information about the year of the test score, this should be stored in rows for a variable called year.

- The function `pivot_longer()` (from the *tidyr* package)   gathers several columns in one column (makes the dataset longer). 
- The function `pivot_wider()` (from the *tidyr* package) spreads one column to several columns (makes the dataset wider). 

## Tidying data II

**pivot_longer()**

- `pivot_longer(data, cols, names_to, values_to=)`
- `data`: the name of the dataset. 
- `cols`: the columns to convert. 
- `names_to`: the new variable where the information that is currently in the column headers (for example the test year) should be stored.
- `values_to`: the variable where the values from the old rows are to be stored.

```{r,eval=FALSE}
tidydata<-pivot_longer(mydataset,cols=7:15,
                       names_to="year",values_to="test_score")
options(dplyr.width = Inf)
head(tidydata)
```

\tiny
```{r,echo=FALSE}
tidydata<-pivot_longer(mydataset,cols=7:15,names_to="year",values_to="test_score",)
options(dplyr.width = Inf)
head(tidydata)
```

(I used `options(dplyr.width = Inf)` to specify the number of columns to print.)
\normalsize


For more details on `pivot_longer()` data see section 12.3.1 in ["R for data science: import, tidy, transform, visualize, and model data." (Wickham & Grolemund, 2016)](https://r4ds.had.co.nz/tidy-data.html).





## Tidying data III

**pivot_wider()**

- `pivot_wider(data, names_from, values_from=)`
- `data`: the name of the dataset. 
- `names_from`: the new columns get their names from this variable. 
- `values_from`: the new columns get their values from this variable. 

```{r,eval=FALSE}
dirtydata<-pivot_wider(tidydata,
                       names_from="year",values_from="test_score")
options(dplyr.width = Inf)
head(dirtydata)
```

\tiny
```{r,echo=FALSE}
dirtydata<-pivot_wider(tidydata,
                       names_from="year",values_from="test_score")
options(dplyr.width = Inf)
head(dirtydata)
```

(I used `options(dplyr.width = Inf)` to specify the number of columns to print.)
\normalsize

For more details on `pivot_wider()` data see section 12.3.2 in ["R for data science: import, tidy, transform, visualize, and model data." (Wickham & Grolemund, 2016)](https://r4ds.had.co.nz/tidy-data.html).


## Data processing I

**filter**

- `filter(data, criteria)`
- We filter specific rows (observations) of a dataset using the `filter()` function (from the dplyr package).
- `data`: the name of the dataset. 
- `...`: the filtering criteria.

```{r,eval=FALSE}
filtered_data<-filter(tidydata,year=="test_year_2")
options(dplyr.width = Inf)
head(filtered_data)
```

\tiny
```{r,echo=FALSE}
filtered_data<-filter(tidydata,year=="test_year_2")
options(dplyr.width = Inf)
head(filtered_data)
```

(I used `options(dplyr.width = Inf)` to specify the number of columns to print.)
\normalsize

For more details on `filter()` see section 5.2 in ["R for data science: import, tidy, transform, visualize, and model data." (Wickham & Grolemund, 2016)](https://r4ds.had.co.nz/transform.html).



## Data processing II

**select**

- `select(data, ...)`
- We select specific columns (variables) of a dataset using the `select()` function (from the dplyr package).
- `data`: the name of the dataset. 
- `...`: the name (or number) of the columns to keep. To remove a variable, add a "-" in front of the variable.

```{r,eval=FALSE}
selected_data<-select(filtered_data,
                      c(person_id,summercamp,test_score))
options(dplyr.width = Inf)
head(selected_data)
```

\tiny
```{r,echo=FALSE, messages=FALSE}
selected_data<-select(filtered_data,
                      c(person_id,summercamp,test_score))
options(dplyr.width = Inf)
head(selected_data)
```

(I used `options(dplyr.width = Inf)` to specify the number of columns to print.)
\normalsize

For more details on `select()` see section 5.4 in ["R for data science: import, tidy, transform, visualize, and model data." (Wickham & Grolemund, 2016)](https://r4ds.had.co.nz/transform.html).



## Data processing III

**rename**

- `rename(data, newname1=oldname1,newname=oldname,...)`
- We rename columns using the rename function
- `data`: the name of the dataset. 
- `newname1`: the new name of the first column to rename. 
- `oldname1`: the old name of the first column to rename.
- `newname2`: the new name of the second column to rename.
- ...
```{r,eval=FALSE}
renamed_data<-rename(selected_data,
                      score=test_score,camp=summercamp)
options(dplyr.width = Inf)
head(renamed_data)
```


\tiny
```{r,echo=FALSE, messages=FALSE}
renamed_data<-rename(selected_data,
                      score=test_score,camp=summercamp)
options(dplyr.width = Inf)
head(renamed_data)
```

(I used `options(dplyr.width = Inf)` to specify the number of columns to print.)

\normalsize

For more details on `rename()` see section 5.4 in ["R for data science: import, tidy, transform, visualize, and model data." (Wickham & Grolemund, 2016)](https://r4ds.had.co.nz/transform.html).



## Data processing IV

**mutate**

- `mutate(data, nameofnewvariable=expression, ...)`
- We create and modify columns using the mutate function
- `data`: the name of the dataset. 
- `nameofnewvariable`: the  name of the first column to rename. 
- `expression`: the definition of the new variable
- ...
```{r,eval=FALSE}
mutated_data<-mutate(renamed_data,
                      camptest=score*camp,constant=1)
options(dplyr.width = Inf)
head(mutated_data)
```

\tiny
```{r,echo=FALSE, messages=FALSE}
mutated_data<-mutate(renamed_data,
                      camptest=score*camp,constant=1)
options(dplyr.width = Inf)
head(mutated_data)
```

(I used `options(dplyr.width = Inf)` to specify the number of columns to print.)
\normalsize

For more details on `mutate()` see section 5.5 in ["R for data science: import, tidy, transform, visualize, and model data." (Wickham & Grolemund, 2016)](https://r4ds.had.co.nz/transform.html).

## Data processing V

**merge**

- `merge(x,y,by="matchingvar")`
- We merge two datasets using the `merge()` function.
- `x`: the name of the first dataset.
- `y`: the name of the second dataset.
- `matchingvar`:  rows with the same value of `matchingvar` in both `x` and `y` are matched. 
- ...
```{r,eval=FALSE}
myotherdataset<-read_csv("example_data2.csv")
merged_data<-merge(mutated_data,myotherdataset,by="person_id")
options(dplyr.width = Inf)
head(merged_data)
```

\tiny
```{r,include=FALSE}
myotherdataset<-read_csv("example_data2.csv")
```

```{r,echo=FALSE, messages=FALSE}
merged_data<-merge(mutated_data,myotherdataset,by="person_id")
options(dplyr.width = Inf)
head(merged_data)
```

(I used `options(dplyr.width = Inf)` to specify the number of columns to print. Some output is hidden.)

\normalsize
For more details on `merge()` see section 13.4.7 in ["R for data science: import, tidy, transform, visualize, and model data." (Wickham & Grolemund, 2016)](https://r4ds.had.co.nz/relational-data.html).


## Data processing VI

**The pipe: %>%**

- Throw the left-hand side value forward into the right-hand side expression.
- So $f(x)$ can be written as as $x$`%>%`$f()$.
- **Example**

```{r,eval=FALSE}
renamed_data<-rename(mydataset,score=test_score)
mutated_data<-mutate(renamed_data,camptest=score*camp)
filtered_data<-filter(mutated_data,female==1)
selected_data<-select(filtered_data,person_id,camptest)
```

can be written as:

```{r,eval=FALSE}
selected_data<-mydataset%>%
               rename(score=test_score)%>%
               mutate(camptest=score*camp)%>%
               filter(female==1)%>%
               select(person_id,camptest)
```

\small



\normalsize

For more details on the pipe  see chapter 18 in ["R for data science: import, tidy, transform, visualize, and model data." (Wickham & Grolemund, 2016)](https://r4ds.had.co.nz/pipes.html#pipes).

## Data processing VII

**group_by** & **summarise**

- `group_by(data,...)`
  - `data`: the name of the dataset. 
  - `...`: the  names of the columns to group the dataset by.

- `summarise(data,varname=expression)`
  - summarises the dataset on the `group_by` (if defined) level.
  - `data`: the name of the dataset. 
  - `varname`: the name of the new variable.
  - `expression`: the definition of the new variable.

```{r,eval=FALSE}
summarised_data<-mydataset%>%
                 group_by(summercamp)%>%
                 summarise(average_score=mean(test_year_2))
print(summarised_data)
```

\tiny
```{r,echo=FALSE, messages=FALSE}
summarised_data<-mydataset%>%
                 group_by(summercamp)%>%
                 summarise(average_score=mean(test_year_2))
print(summarised_data)
```

\normalsize

For more details see  ["section 5.6 in R for data science: import, tidy, transform, visualize, and model data." (Wickham & Grolemund, 2016)](https://r4ds.had.co.nz/transform.html#grouped-summaries-with-summarise).


## Base graphics I

**base** refers to base R (without any functionality from loaded packages).

`plot(x,y,..)`

-`x` the variable to plot on the x-axis.

-`y` the variable to plot on the y-axis.

-`...` settings ()

  - ` type = "l"`: line chart type (try also  "o", "p", "l", & "b").
  - `lty = "dotted"`: dotted line type (try also "dashed").
  - `col = "blue"`: blue line.
  - `lwd=2`: line width.
- `lines()` or `points()` to add more lines

For more details see  [R Base Graphics: An Idiot's Guide](https://rstudio-pubs-static.s3.amazonaws.com/7953_4e3efd5b9415444ca065b1167862c349.html).



## Base graphics II


```{r,eval=FALSE, }
var1<-c(15, 17, 17, 20, 25)
var2<-c(55, 67, 62, 60, 70)
var3<-c(75, 67, 60, 62, 80)
plot(var1,var2,
     type="l",lty="dashed",col="green",lwd=2)
lines(var1,var3,
      type="l",lty="solid",col="blue",lwd=2)
```



```{r,echo=FALSE,fig.width=7,fig.height=6, fig.align = "center", out.width = '150pt'}
var1<-c(15, 17, 17, 20, 25)
var2<-c(55, 67, 62, 60, 70)
var3<-c(75, 67, 60, 62, 80)
plot(var1,var2,
     type="l",lty="dashed",col="green",lwd=2)
lines(var1,var3,
      type="l",lty="solid",col="blue",lwd=2)
```




## ggplot I


**ggplot2** a grammar for graphics

- `ggplot(data,aes(x,y,...))`
  - `data`: the name of the dataset. 
  - `...`: `aes()` the aesthetic mappings.
  - `x` the variable to plot on the x-axis.
  - `y` the variable to plot on the y-axis.

- `+geom_line()`
  - `+` add a layer to the ggplot object
  - `geom_line()` add a line chart using the data and the aesthetic mappings specified in ggplot() (`geom_line` inherits the settings specified in `ggplot()`).

- `+geom_point(data,aes(x,y,...))`
- `+` add a layer to the ggplot object
- `geom_point()` add a scatter plot using the data and the aesthetic mappings specified specifeid within `geom_point()`.

- `+theme()`: specify theme settings (colors, position etc.)
- `+labs()`: specify axes titles, chart title, caption, legend titles, etc..


For more details see  ["chapter 3 in R for data science: import, tidy, transform, visualize, and model data." (Wickham & Grolemund, 2016)](https://r4ds.had.co.nz/data-visualisation.html#first-steps). 
                                                                                                                                           
                                                                                                                                           
## ggplot II


**ggplot2** a grammar for graphics


```{r,eval=FALSE, }
ggplot(mydataset,aes(x=parental_lincome,y=test_year_2))+
 geom_line()
```

```{r,echo=FALSE,fig.width=7,fig.height=6, fig.align = "center", out.width = '150pt'}
ggplot(mydataset,aes(x=parental_lincome,y=test_year_2))+geom_point()
```



## Tidyverse summary

- Tidyverse package tools for working with data: load, tidy, process, visualize data.

- We install packages with `install.package()`.

- We load packages with `library()`.

- We use `pivot_wider()` and `pivot_longer()` to tidy the dataset.

- We use `mutate()` to create new/modify columns in our dataset.

- We use `select()` to specify which columns to keep/remove.

- We use `filter()` to specify which rows to keep.

- We use `group_by()` and `summarise()` to create aggregate statistics.

- We use `ggplot()` to create charts.

- We use `merge()` to merge datasets.

For more details on  tidyverse  see ["R for data science: import, tidy, transform, visualize, and model data." (Wickham & Grolemund, 2016)](https://r4ds.had.co.nz/). 
                                                                      
                                                                      
# 3.  Working with matrices in R

## A vector
- We would like to enter the following vector $A$ into R

$$A= \left[\begin{matrix}3\\5\\4\end{matrix}\right]$$

- We already know how to do this. We simply use `c()`:

```{r}
A<-c(3,5,4)
A
```
- Note that R prints it as row, but it is a column vector. 



## A vector transposed

- To verify that $A$ is really a column vector, let's consider the transpose of A:

$$A^T= \left[\begin{matrix}3,5,4\end{matrix}\right]$$
- which we can obtain in R by means of the transpose function, `t()`:

```{r}
t(A)
```

- Where the `m` in `[m,n]` refers to the **row** and the `n` to the **column**.

- and let's consider the transpose of the transposed vector to get back to the original $A$ vector.:
```{r}
t(t(A))
```

## The matrix function

- We can also explictly create vectors and matrices using the `matrix()` function. 
- To create our A vector, we write:
```{r}
A<-matrix(c(3,5,4),ncol=1)
A
```
- Note the difference between
```{r}
A<-matrix(c(3,5,4),ncol=1)
class(A)
```
and
```{r}
A<-c(3,5,4)
class(A)
```

## Entering a matrix with the matrix function 

**Creating a 2x2 matrix**

- Let us now consider a 2 by 2 matrix $B$:

$$B= \left[\begin{matrix}3,5\\11,2\end{matrix}\right]$$
- which we can enter as:
```{r}
B<-matrix(c(3,11,5,2),ncol=2)
B
```
- R first fills the first column, then the second etc...

- And the transpose of `B`:
```{r}
t(B)
```


## Subsetting

- We can extract a subset of an object using squared brackets `[row,col]`

```{r}
B<-matrix(c(3,11,5,2),ncol=2)
C<-B[2,1]
print(C)
```
  - The first number in the brackets, 2, tells R that we want the second row.
  - The second number in the brackets, 1, tells R that we want the first column. 
  - We therefore extract the value in the second row and the first column. 
  
- We can also extract a range, say that we want the elements in row 1 to 2 and column 1:

```{r}
B<-matrix(c(3,11,5,2),ncol=2)
C<-B[1:2,1]
print(C)
```

For more details on subsetting R objects see  [chapter 9 in "R Programming for Data Science" (Peng, 2019)](https://bookdown.org/rdpeng/rprogdatascience/subsetting-r-objects.html)

## Addition

**Adding a number to a matrix**

- Let $\alpha$ be a number (a scalar), then $\alpha + B$ is:
$$\alpha B= \left[\begin{matrix}\alpha +  3,\alpha + 5\\\alpha +  11,\alpha +  2\end{matrix}\right]$$


- and in R:
```{r}
B<-matrix(c(3,11,5,2),ncol=2)
alpha<-0.5
C<-alpha+B
print(C)
```

## Addition

**Adding two matrices together**

- Consider the following two matrices

$$ C= \left[\begin{matrix} 1,2 \\ 3, 4 \end{matrix}\right] \text{ and  }
   D= \left[\begin{matrix} 5,6 \\ 7, 8 \end{matrix}\right] $$
  
- The sum of these two matrices is then given by::

$$C + D=\left[\begin{matrix} 1 + 5,2 + 6 \\ 3 + 7, 4 + 8 \end{matrix}\right]$$
- and in R:
```{r}
C<-matrix(c(1,3,2,4),ncol=2)
D<-matrix(c(5,7,6,8),ncol=2)
E<-C+D
print(E)
```


## Addition


**Warning: pay attention to dimensions of matrices**

- Note: the dimensions have to align when adding two matrices together:

```{r, error=TRUE}
E<-matrix(c(1,3,2,4),ncol=1)
F<-matrix(c(5,7,6,8),ncol=2)
E+F
```

- $E$ is a $1\times 4$ matrix.
- $F$ is a $2\times 2$ matrix.

  - We want to add the element in the first row and first column of $E$ to the element in the first row and the first column of $F$ That's okay.
  
  ...
  
  - We want to add the element in the third row and first column of $E$ to the element in the third row and the first column of $F$. That's not doable, because  $F$ only has two rows.
  
  
## Multiplication

**Multiplying a matrix with a number**


- Let $\alpha$ be a number (a scalar), then $\alpha B$ is:

$$\alpha B= \left[\begin{matrix}\alpha \times  3,\alpha \times 5\\\alpha\times  11,\alpha \times  2\end{matrix}\right]$$

- and in R:
```{r}
B=matrix(c(3,11,5,2),ncol=2)
alpha=0.5
alpha*B
```


## Multiplication

**Element-wise multiplication**


- Consider the following two matrices

$$ C= \left[\begin{matrix} 1,2 \\ 3, 4 \end{matrix}\right] \text{ and  }
   D= \left[\begin{matrix} 5,6 \\ 7, 8 \end{matrix}\right] $$
   
- The Hadamard product (or element-wise multiplication) of matrices $C$ and $D$ is then given by:

$$E=C\circ D=\left[\begin{matrix} 1\times 5,2 \times 6 \\ 3 \times 7, 4 \times 8 \end{matrix}\right]$$

- and in R:

```{r}
C=matrix(c(1,3,2,4),ncol=2)
D=matrix(c(5,7,6,8),ncol=2)
C*D
```


## Multiplication

**Warning: pay attention to dimensions of matrices**

- Note: element-wise multiplication of two matrices also requries that dimensions (i.e. number of rows and columns) match :

```{r, error=TRUE}
E=matrix(c(1,3,2,4),ncol=1)
F=matrix(c(5,7,6,8),ncol=2)
E*F
```

- $E$ is a $1\times 4$ matrix.
- $F$ is a $2\times 2$ matrix.

  -We want to multiply the element in the first row and first column of $E$ with the element in the first row and the first column of $F$ That's okay.
  - ...
  - We want to multiply the element in the third row and first column of $E$ with the element in the third row and the first column of $F$. That's not doable, because  $F$ only has two rows.
  
  
  
## Multiplication

**Matrix multiplication **


- Consider again the following two matrices

$$ C= \left[\begin{matrix} 1,2 \\ 3, 4 \end{matrix}\right] \text{ and  }
   D= \left[\begin{matrix} 5,6 \\ 7, 8 \end{matrix}\right] $$
   
- Let's now consider  the  product of matrices $E$ and $D$:

$$C  D=\left[\begin{matrix} 
1\times 5+2\times 7,
1\times 6+2\times 8\\
3\times 5+4\times 7,
3\times 6+4\times 8
\end{matrix}\right]$$

- and in R:

```{r}
C=matrix(c(1,3,2,4),ncol=2)
D=matrix(c(5,7,6,8),ncol=2)
C%*%D
```

## Multiplication

**Warning: pay attention to dimensions of matrices**

- Note: matrix multiplication of two matrices  requries that the number of rows in the left hand side matrix correspond to the number of columns in the right hand side matrix.

```{r, error=TRUE}
E=matrix(c(1,3,2,4),ncol=1)
F=matrix(c(5,7,6,8),ncol=2)
E%*%F
```

- $E$ is a $1\times 4$ matrix.
- $F$ is a $2\times 2$ matrix.

  -We want to multiply the elements of the first row in matrix $E$ to the elements of the first column of matrix $F$, but the former has one element and the latter has two elements!
  
## Some special matrices 

- A 0-matrix (all entries are zero):

```{r, error=TRUE}
matrix(0, nrow = 2, ncol = 2)
```

- A $J$ matrix (all entries are 1s):
```{r, error=TRUE}
matrix(1, nrow = 2, ncol = 2)
```

- A matrix where all  entries outside the  diagonal are  zero:
```{r, error=TRUE}
diag(c(1,2,3))
```

## Some special matrices 

- The identity matrix: a diagonal matrix where all elements in the diagonal are 1. 

```{r, error=TRUE}
diag(c(1,1))
```

- An Identity matrix satisfies $IA=AI=A$, where A is a matrix. 
```{r, error=TRUE}
A<-matrix(c(1,3,4,5),ncol=2)
I<-diag(c(1,1))
A%*%I
```

We can also apply `diag()` on matrix to extract the diaognal

```{r, error=TRUE}
A=matrix(c(1,3,4,5),ncol=2)
diag(A)
```




## The inverse of a matrix

- Let $A$ be a $n \times n$ matrix (a square matrix, because the number of rows equals the number of columns).
- Let $B$ be $n \times n$ matrix which multiplied by matrix $A$ gives the identity matrix:

$$ AB=BA=I$$

- The matrix B is called A's inverse, $B=A^{-1}$.
- Finding the inverse matrix is numerically complicated. But luckily we can ask R to do it for us by means of the `solve()` function:

```{r, error=TRUE}
A=matrix(c(1,3,4,5),ncol=2)
solve(A)
```

- let's test it:

```{r, error=TRUE}
solve(A)%*%A
```

## The determinant of a matrix

- A matrix is not invertible if the determinant is zero (the matrix is then called singular).
- The determinant of matrix $A$ is written as $det(A)$ or $|A|$.
- For a 2x2 matrix, the determinant is defined as

$$det(A)=|A|= \begin{vmatrix} a,b\\c,d\end{vmatrix}  =a\times d-b\times c.$$
- So for the A matrix defined earlier it is given by:


$$det(A)= \begin{vmatrix} 1,3\\4,5\end{vmatrix}  =1\times 5-3\times 4=-7.$$

```{r, error=TRUE}
A=matrix(c(1,3,4,5),ncol=2)
det(A)
```

## Combining matrices

**Column bind:** `cbind(A,B,..)`

- combines matrices $A$, $B$, .. horizontally (binds the columns).

```{r, error=TRUE}
A=matrix(c(1,3,4,5),ncol=2)
B=matrix(c(1,3,4,5),ncol=2)
cbind(A,B)
```

**Row bind:** `rbind()`

- combines matrices $A$, $B$, .. vertically (binds the columns).

```{r, error=TRUE}
rbind(A,B)
```

## Application: ordinary least squares

- Let's return to our data and estimate the following model using Ordinary Least Squares (OLS): 

\vspace{-12pt}

$$test\_year\_6_i=\beta_0+\beta_1 parental\_lincome+\beta_2 summercamp_i+e_i$$

- We can achive this with `lm()` function in R:

```{r,eval=FALSE}
mydataset<-read_csv("example_data1.csv")
my_lm<-lm(test_year_6~parental_lincome+summercamp,data=mydataset)
summary(my_lm)
```

\normalsize
  - We specify the model to estimate on the form: `y~x1+x2+..` (R automatically adds a constant).
  - We specify the data object to use using `data=..`.
  
- We store the result of fitting the model using OLS in the object called `my_lm`
- We use the `summary()` function to summarize the results.


## Application: ordinary least squares

- Let's check the output


```{r,eval=FALSE}
mydataset<-read_csv("example_data1.csv")
my_lm<-lm(test_year_6~parental_lincome+summercamp,data=mydataset)
summary(my_lm)
```
\tiny
```{r,include=FALSE}
mydataset<-read_csv("example_data1.csv")
```
```{r,echo=FALSE}
my_lm<-lm(test_year_6~parental_lincome+summercamp,data=mydataset)
summary(my_lm)
```


## Application: Ordinary Least Squares

*Manual OLS using R* 

- Let's try to manually reproduce these results from lm() using the matrix tools we just covered.
- We know that the OLS estimates in matrix form are given by:

$$\hat{\beta}=(X^TX)^{-1}X^Ty$$

- We know how to find the inverse, how to multiply matrices and how to transpose matrices in R. We are ready!

**But**

- We first need to get the data from the dataset into the matrix.


```{r,eval=FALSE}
mydataset<-read_csv("example_data1.csv")
class(mydataset)
```
\tiny
```{r,include=FALSE}
mydataset<-read_csv("example_data1.csv")
```
```{r,echo=FALSE}
class(mydataset)
```

\normalsize

- `mydataset` is a `tibble` (or a data frame), not a matrix. 
- A matrix is homogeneous (just like vectors created with `c()`).
- Data frames allow for a mix of types (integer, double, character).

## Application: Ordinary Least Squares

**From data frame to matrix: method 1**

- We can access a specific column of a dataframe using the `$` symbol:

```{r,eval=FALSE}
mydataset<-read_csv("example_data1.csv")
mydataset$test_year_6
```
\tiny
```{r,include=FALSE}
mydataset<-read_csv("example_data1.csv")
```
```{r,echo=FALSE}
mydataset$test_year_6
```
\normalsize

- let's save data  in a column vector called y:

```{r,eval=FALSE}
mydataset<-read_csv("example_data1.csv")
y<-matrix(mydataset$test_year_6,ncol=1)
```

- Note that we also could use the `[]` subsetting method, but this requires us to know the orde of the columns in the dataset.

## Application: Ordinary Least Squares

**From data frame to matrix: method 2**

- We can convert a data frame to a matrix using the `as.matrix()` function:

```{r,eval=FALSE}
X<-read_csv("example_data1.csv")%>%
            select(parental_lincome,summercamp)%>%
            mutate(constant=1)%>%
            as.matrix()
class(X)
```
\tiny
```{r,include=FALSE}
x<-read_csv("example_data1.csv")
```
```{r,echo=FALSE}
X<-x%>%select(parental_lincome,summercamp)%>%
            mutate(constant=1)%>%
            as.matrix()
class(X)
```

\normalsize
- let's check the content of `X` by printing the first five rows and all columns:

```{r,eval=FALSE}
print(X[1:5,])
```

\tiny
```{r,echo=FALSE}
print(X[1:5,])
```

\normalsize

## Application: Ordinary Least Squares

**Let's find the OLS estimates**

- The point-estimates of the OLS estimator are given by:

$$\hat{\beta}=(X^TX)^{-1}X^Ty$$

- Let's translate this into R.

\small
```{r,eval=FALSE}
# load dataset
mydataset<-read_csv("example_data1.csv")
# extract the dependent variable and store as column vector y
y<-matrix(mydataset$test_year_6,ncol=1)
# extract the covariates to include and create a constant and as matrix X
X<-mydataset%>%
   select(parental_lincome,summercamp)%>%
   mutate(constant=1)%>%
   as.matrix()
# implement OLS formula
betahat<-solve(t(X)%*%X)%*%t(X)%*%y
# show betahat vector
print(betahat)
```
\tiny
```{r,include=FALSE}
# load dataset
mydataset<-read_csv("example_data1.csv")
# extract the dependent variable and store as column vector y
y<-matrix(mydataset$test_year_6,ncol=1)
# extract the covariates to include and create a constant and as matrix X
X<-mydataset%>%
   select(parental_lincome,summercamp)%>%
   mutate(constant=1)%>%
   as.matrix()
# implement OLS formula
betahat<-solve(t(X)%*%X)%*%t(X)%*%y

```
```{r,echo=FALSE}
# show beta vector
betahat
```

\normalsize
- Estimated coefficients are identical to the results obtained with `lm()`!

## Application: Ordinary Least Squares

**Fitted values**

- the fitted values are given by $X\hat{\beta}$.
- the residuals are given by $y-X\hat{\beta}$.
- we can create a q-q plot of the residuals using base graphics:

\small
```{r,eval=FALSE}
#calculate residuals
residuals<-(y-X%*% betahat)
# create a q-q plot
qqnorm(residuals)
```
\tiny
```{r,include=FALSE}
# load dataset
mydataset<-read_csv("example_data1.csv")
# extract the dependent variable and store as column vector y
y<-matrix(mydataset$test_year_6,ncol=1)
# extract the covariates to include and create a constant and as matrix X
X<-mydataset%>%
   select(parental_lincome,summercamp)%>%
   mutate(constant=1)%>%
   as.matrix()
# implement OLS formula
betahat=solve(t(X)%*%X)%*%t(X)%*%y

```
```{r,echo=FALSE,fig.width=7,fig.height=6, fig.align = "center", out.width = '150pt'}
# show beta vector
residuals<-(y-X%*% betahat)
# create histogram
qqnorm(residuals)
```


## Matrices in R - summary

- Create column vector A: `A<-c()`.
- Create matrix A: `A<-matrix()`.
- Convert B to a matrix and store it in A: `A<-as.matrix(B)`.
- Transpose matrix A: `t(A)`.
- Inverse of matrix A: `solve()`.
- Element-wise multiplication of matrix `A` and `B`: `A*B`.
- Matrix multiplication of matrix `A` and `B`: `A%*%B`.
- Extract the column named `col1` from data frame `df`: `df$col1`.
- OLS estimator: `betahat=solve(t(X)%*%X)%*%t(X)%*%y`.


       
                                                                                                                                           


# 4. Functions, control structures and loops in R

## Defining functions

**What is a function**?

- a set of R statements that perform a task given a set of provided arguments. 

- Example:  `lm(test_year_6~parental_lincome+summercamp,data=mydataset)`

  - The function `lm()` estimates coefficients of a linear model.
  - The model is provided as the first argument (`test_year_6~parental_lincome+summercamp`)
  - The dataset is provided as a second (named) argument ( `mydataset`).

**User defined functions**

- We can easily create our own functions in R.
- The syntax is as follows:

```{r, eval=FALSE}
function_name <- function(arg_1, arg_2, ...) {
   Function body 
}
```
The function consists of four parts:

1. The function name.
2. The arguments (placeholders for settings, datasets etc). 
3. The function  body (a collection of statements to carry out using the arguments provided).
4. Return value (the last expression of the function)


## Our first function

**Let's define a function**

1. name: Hansfunction
2. arguments: `x` and `y`
3. function body:  `z=x*y`
4. return: return(z)

- in R:
```{r}
Hansfunction <- function(x, y) {
   z<-x*y
   z
}

```
- Let's try the function
```{r}
Hansfunction(3,6)
```

- What if we forget to state an argument?
```{r,error=TRUE}
Hansfunction(3)
```


## Default values

**Let's define a function with default values**

- To avoid such cases, we can specify **default** values:
- When defining the function, we set the arguments equal to their default values.
- Let's define that function
```{r}
Hansfunction <- function(x=2, y=2) {
   z<-x*y
   z
}
Hansfunction(3)
```

- This works well, but if you accidentially forgot an argument? It would be nice with a warning.


## Control structures

**Control structures**

- We can use **control structures** to control the statements executed by our function.
- Here is an example of a control structure in plain English:

```{r, eval=FALSE,error=TRUE}
if logical test evaluates to true do the following
    statements to execute if TRUE
else do the following
    statements to execute if not TRUE
```

- and in terms of R syntax:

```{R,eval=FALSE,error=FALSE}
if (logical test){
  
  }
  else{
  
}
```

- A logical test is a statement that evaluates to TRUE or FALSE, for example:  
  - "5 is greater than 3" The statement is TRUE
  - "3 is greater than 5" The statement is FALSE

- Control statements can also be used outside functions (in scripts, loops etc).

## Control structures

**Control structures in Hansfunction()**

```{r}
Hansfunction <- function(x=2, y=3) {
  if (missing(x)|missing(y)){
     print("Warning: Not all arguments provided. Default values used.")
  }
  else{
     print("Well done, you specified all arguments!")
  }
     z<-x*y
     z
}
Hansfunction(3)
```
- here we use the function `missing()` to test whether the argument missing.
- the `|` corresponds to "or" (the logical expression evaluates to true if x OR y are missing).
- We can use the symbol "&" if we only want the expression to evaluate to true if both are x and y are missing. 

## Local vs global

- Global R objects are accessible from anywhere.
- Local R objects only exist in local environment.
\small

```{r}
assign_to_z <- function(x) {
     z<-x
}
z=5
assign_to_z(3)
print(z)
```
\normalsize
- What is going on? Inside a function is a local environment.
- Changing and creating objects within local environments does affect global environments.
- Unless we explicitly tell R to do so:

\small
```{r}
assign_to_z <- function(x) {
     z<<-x
}
z=5
assign_to_z(3)
print(z)
```
\normalsize
- Note the use of `<<-` (the super assignment operator).

## Our own lm() function

**Let's build our own lm() function**

- We now use the tools from the matrix section and combine them with the function definitions to create our own lm function.

\small
```{r,eval=FALSE}
mylm <- function(y,x,data) {
  # specify dataset
  df<-data
  # extract the dependent variable and the covariates
  yvar<-df%>%select(y)%>%as.matrix()
  Xvar<-df%>%select(x)%>%mutate(constant=1)%>%as.matrix()
  # implement OLS formula and return betahat vector
  solve(t(Xvar)%*%Xvar)%*%t(Xvar)%*%yvar
}
# load data
mydataset<-read_csv("example_data1.csv")
# try our new function
mylm(x=c("parental_lincome","summercamp"),y="test_year_4",data=mydataset)

```
\tiny
```{r,include=FALSE}
mylm <- function(y,x,data) {
  # specify dataset
  df<-data
  # extract the dependent variable and the covariates
  yvar<-df%>%select(y)%>%as.matrix()
  Xvar<-df%>%select(x)%>%mutate(constant=1)%>%as.matrix()
  # implement OLS formula and return betahat vector
  solve(t(Xvar)%*%Xvar)%*%t(Xvar)%*%yvar
}
mydataset<-read_csv("example_data1.csv")

```
```{r,echo=FALSE}
mylm(x=c("parental_lincome","summercamp"),y="test_year_4",data=mydataset)

```
                                                                        
## Loops

**For loop**

- A loop repeats a set of statements. 
- The number of times the statements are repeated is stated in the loop *header*.
- The set statements are provided in the loop *body*.
- Example:

\small
```{r,eval=FALSE}
for (x in 1:3){
  print(x)
}
```
\tiny
```{r,echo=FALSE}
for (x in 1:3){
  print(x)
}
```
\normalsize
- The loop header `for (x in 1:3){` states that the loop should be repeated 3 times:
  1. Once where `x` has the value 1
  2. Once where `x` has the value 2
  3. Once where `x` has the value 3.
  
- The loop header  states that in each loop *iteration* the statment `print(x)` should be executed. 

## Loops

**While loop**

- We can also create a loop that repats itself until a certain condition is violated.
- This is called a **while** loop.
- The loop body statements are repeated until the while condition is violated. 
- Example:

\small
```{r,eval=FALSE}
x=1
while (x<5){
  print(x)
  x=x+1
}
```
\tiny
```{r,echo=FALSE}
x=1
while (x<5){
  print(x)
  x=x+1
}
```
\normalsize
- the object `x` is initiated with a value of 1.
- the loop is repeated until `x<5` evaluates to false.
- in every iteration we:
  - print the value of x.
  - add the value of 1 to x.

## Application: maximum likelihood

**Maximum likelihood**: find the parameters that maximize the likelihood that we observe what we've observed, given an assumed functional form and  distribution.

- Application: estimate the probability that a child probability participates in the summer school using a probit model.

- **Benchmark**: R's built-in function

\small
```{r ,eval=FALSE}
mydataset<-read_csv("example_data1.csv")
# Estimate the probit model
probit<-glm(summercamp~parental_lincome,
            family = binomial(link = "probit"), data = mydataset)
# Show parameter estimates
summary(probit)
```
\tiny
```{r, include=FALSE}
# Probit estimation using glm
mydataset<-read_csv("example_data1.csv")
```

```{r ,echo=FALSE}
# Estimate the probit model
probit<-glm(summercamp~parental_lincome,
            family = binomial(link = "probit"), data = mydataset)
# Show parameter estimates
summary(probit)
```



## Application: maximum likelihood

- The likelihood for a single observation:

$$L(\beta;y_i,x_i)=[\Phi(x'_i\beta)]^{y_i}[1-\Phi(x'_i\beta)]^{1-y_i}$$

- Observations are assumed to be $iid$, we can therefore write the likelihood of the entire sample as the product of the individual likelihoods:

$$L(\beta;y,X)=\prod_{i=1}^N [\Phi(x'_t\beta)]^{y_i}[1-\Phi(x'_t\beta)]^{1-y_i}$$

- The **log**-likelihood is then given by:

$$l(\beta;y,X)=\sum_t\left(y_t\ln\Phi(x'_t\beta) + (1-y_t)\ln\left(1-\Phi(x'_t\beta)\right)\right)$$

- **R implementation**
  - $\Phi()$  is the cumulative distribution function of the standard normal distribution, which we implement in R with `pnorm()`.
  - `sum()` computs the sum.
  - We can therefore implement the above in R as:
`l<-sum(y*log(pnorm(xb))+(1-y)*log(1-pnorm(xb)))`  
  

## Application: maximum likelihood

- The log-likelihood for $\beta=[-11.9,0.79]$ (the values R found for us).
\small
```{r, eval=FALSE}
# load data
df<-read_csv("example_data1.csv")
# y variable
y<-df%>%select(summercamp)%>%as.matrix()
# x variable 
X<-df%>%select(parental_lincome)%>%mutate(constant=1)%>%as.matrix()
# xb (note constant is given last)
xb<-X%*%c(0.79,-11.9)
# log likelihood
l<-sum(y*log(pnorm(xb))+(1-y)*log(1-pnorm(xb)))
# return value
l
```
\tiny
```{r, include=FALSE}
# load data
df<-read_csv("example_data1.csv")
```
```{r, echo=FALSE}
# y variable
y<-df%>%select(summercamp)%>%as.matrix()
# x variable 
X<-df%>%select(parental_lincome)%>%mutate(constant=1)%>%as.matrix()
# xb (note constant is given last)
xb<-X%*%c(0.79,-11.9)
# log likelihood
l<-sum(y*log(pnorm(xb))+(1-y)*log(1-pnorm(xb)))
# return value
print(l)
```

\normalsize 

- Okay, but how do we know this is maximized? Let's evaluate the log likelihood value for various values of beta. To do this we:
  1. Wrap the likelihood expression in a function.
  2. Loop over the function and use different values.
  
## Application: maximum likelihood

**1. Our likelihood function**
\small
```{r,eval=FALSE}
my_loglikelihood <- function(y,x,beta,data) {
  # specify dataset
  df<-data
  # extract the dependent variable and the covariates
  yvar<-df%>%select(y)%>%as.matrix()
  Xvar<-df%>%select(x)%>%mutate(constant=1)%>%as.matrix()
  # beta
  betavec=beta
  # xb (note constant is given last)
  xb<-Xvar%*%betavec
  # log likelihood
  l<-sum(yvar*log(pnorm(xb))+(1-yvar)*log(1-pnorm(xb)))
  # return (explicitly tell R to return this object)!
  return(l) 
}
# load data
mydataset<-read_csv("example_data1.csv")
# try our new function
my_loglikelihood(x="parental_lincome",y="summercamp",
                 beta=c(0.79,-11.9) ,data=mydataset)
```
\tiny
```{r,include=FALSE}
# load data
mydataset<-read_csv("example_data1.csv")


```
```{r,echo=FALSE}
my_loglikelihood <- function(beta,y,x,data) {
  # specify dataset
  df<-data
  # extract the dependent variable and the covariates
  yvar<-df%>%select(y)%>%as.matrix()
  Xvar<-df%>%select(x)%>%mutate(constant=1)%>%as.matrix()
  # beta
  betavec=beta
  # xb (note constant is given last)
  xb<-Xvar%*%betavec
  # log likelihood
  l<-sum(yvar*log(pnorm(xb))+(1-yvar)*log(1-pnorm(xb)))
  # return
  l
}
# load data
# try our new function
my_loglikelihood(x="parental_lincome",y="summercamp",
                 beta=c(0.79,-11.9),data=mydataset)

```
## Application: maximum likelihood

**2. Loop over values**

- Simplification: keep $\beta_0$ constant at -11.9 and only change $\beta_1$:
```{R}
# loop over values of beta1
for (i in seq(0,1,by=0.2)){
  l<-(my_loglikelihood(x="parental_lincome",y="summercamp",
                 beta=c(i,-11.9),data=mydataset))
  print(paste("For beta1=" ,i, " the log-likelihood is: ",l,".", sep=""))
}

```

- Okay, that works, but 5 values are a bit boring. Let's try more!

## Application: maximum likelihood

- Let's loop over more values, store all results in a data frame and show the likelihood in a chart as a function of $\beta_1$:
\small 
```{R,fig.width=7,fig.height=4, fig.align = "center", out.width = '150pt'}
# create empty matrix to store values
df<-data.frame(beta1=seq(0,1.1,by=0.01),loglikelihood=NA)
# loop over values of beta1
for (i in 1:nrow(df)){
  beta1<-df[i,1]
  df[i,2]<-my_loglikelihood(x="parental_lincome",y="summercamp",
                 beta=c(beta1,-11.9),data=mydataset)
}
# let's plot the log likelihood as a function of beta 1
ggplot(df,aes(x=beta1,y=loglikelihood))+geom_line()
```

## Application: maximum likelihood

- The chart indicates that the maximum value of the log-likelihood function could be around 0.79 (as the R built-in function suggest).
- But how do we find the exact values? And how about $\beta_0$?
- We use a built-in **optimizer**. 
    - A function to maximize or minimize to mimize an expression.
- One such function is `optim()`, In `optim`() we specify:
  - `par`:  starting values for the parameters.
  - `fn`: the function to maximize (or minimize).
  - `control` a control parameter (`fnscale=-1` is a scaling parameter that we apply on the values. By setting it to -1 it becomes a maximization problem).
  - `...`: options passed on to the function in `fn`.

\small

```{r ,eval=FALSE}
# use the R function optim to optimize ll
optim(par=c(0,0), fn=my_loglikelihood, control=list(fnscale = -1),
      x="parental_lincome",y="summercamp",data=mydataset)
```

\tiny

```{r ,echo=FALSE}
# use the R function optim to optimize ll
optim(par=c(0,0), fn=my_loglikelihood, control=list(fnscale = -1),
      x="parental_lincome",y="summercamp",data=mydataset)
```

## Functions, control structures, loops - summary

\small
- We **define functions** using the following syntax:
```{r ,eval=FALSE}
function_name <- function(arg_1, arg_2, ...) {
   function body 
}
```

- We  control the flow of our function using control structure:

```{r ,eval=FALSE}
if (logical test){
  action to do if logical test evaluates to true
}
else {
  action to do if logical test evaluates to false
}
```

- We repeat statements using loops

```{r ,eval=FALSE}
for (x in range){
  action to repeat for all values in range
}
```

- We can combine these tools and implement a maximum likelihood estimator.

## The end

Please send suggestions for improvements and notes about identified mistakes to h.h.sievertsen@bristol.ac.uk.

Thanks.


